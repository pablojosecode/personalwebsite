"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FunctionModule = void 0;
const aggregate_function_node_js_1 = require("../operation-node/aggregate-function-node.js");
const coalesce_parser_js_1 = require("../parser/coalesce-parser.js");
const reference_parser_js_1 = require("../parser/reference-parser.js");
const select_parser_js_1 = require("../parser/select-parser.js");
const raw_builder_js_1 = require("../raw-builder/raw-builder.js");
const query_id_js_1 = require("../util/query-id.js");
const aggregate_function_builder_js_1 = require("./aggregate-function-builder.js");
/**
 * Helpers for type safe SQL function calls.
 *
 * You can always use the {@link sql} tag to call functions and build arbitrary
 * expressions. This module simply has shortcuts for most common function calls.
 *
 * ### Examples
 *
 * ```ts
 * const { count } = db.fn
 *
 * await db.selectFrom('person')
 *   .innerJoin('pet', 'pet.owner_id', 'person.id')
 *   .select([
 *     'person.id',
 *     count('pet.id').as('pet_count')
 *   ])
 *   .groupBy('person.id')
 *   .having(count('pet.id'), '>', 10)
 *   .execute()
 * ```
 *
 * The generated SQL (PostgreSQL):
 *
 * ```sql
 * select "person"."id", count("pet"."id") as "pet_count"
 * from "person"
 * inner join "pet" on "pet"."owner_id" = "person"."id"
 * group by "person"."id"
 * having count("pet"."id") > $1
 * ```
 */
class FunctionModule {
    constructor() {
        this.avg = this.avg.bind(this);
        this.coalesce = this.coalesce.bind(this);
        this.count = this.count.bind(this);
        this.countAll = this.countAll.bind(this);
        this.max = this.max.bind(this);
        this.min = this.min.bind(this);
        this.sum = this.sum.bind(this);
    }
    /**
     * Calls the `avg` function for the column given as the argument.
     *
     * This sql function calculates the average value for a given column.
     *
     * For additional functionality such as distinct, filtering and window functions,
     * refer to {@link AggregateFunctionBuilder}. An instance of this builder is
     * returned when calling this function.
     *
     * ### Examples
     *
     * ```ts
     * const { avg } = db.fn
     *
     * db.selectFrom('toy')
     *   .select(avg('price').as('avg_price'))
     *   .execute()
     * ```
     *
     * The generated SQL (PostgreSQL):
     *
     * ```sql
     * select avg("price") as "avg_price" from "toy"
     * ```
     *
     * You can limit column range to only columns participating in current query:
     *
     * ```ts
     * db.selectFrom('toy')
     *   .select(qb => qb.fn.avg('price').as('avg_price'))
     *   .execute()
     * ```
     *
     * If this function is used in a `select` statement, the type of the selected
     * expression will be `number | string` by default. This is because Kysely can't know the
     * type the db driver outputs. Sometimes the output can be larger than the largest
     * javascript number and a string is returned instead. Most drivers allow you
     * to configure the output type of large numbers and Kysely can't know if you've
     * done so.
     *
     * You can specify the output type of the expression by providing the type as
     * the first type argument:
     *
     * ```ts
     * const { avg } = db.fn
     *
     * db.selectFrom('toy')
     *   .select(avg<number>('price').as('avg_price'))
     *   .execute()
     * ```
     *
     * Sometimes a null is returned, e.g. when row count is 0, and no `group by`
     * was used. It is highly recommended to include null in the output type union
     * and handle null values in post-execute code, or wrap the function with a {@link coalesce}
     * function.
     *
     * ```ts
     * const { avg } = db.fn
     *
     * db.selectFrom('toy')
     *   .select(avg<number | null>('price').as('avg_price'))
     *   .execute()
     * ```
     */
    avg(column) {
        return new aggregate_function_builder_js_1.AggregateFunctionBuilder({
            aggregateFunctionNode: aggregate_function_node_js_1.AggregateFunctionNode.create('avg', (0, reference_parser_js_1.parseSimpleReferenceExpression)(column)),
        });
    }
    /**
     * Calls the `coalesce` function for given arguments.
     *
     * This sql function returns the first non-null value from left to right, commonly
     * used to provide a default scalar for nullable columns or functions.
     *
     * If this function is used in a `select` statement, the type of the selected
     * expression is inferred in the same manner that the sql function computes.
     * A union of arguments' types - if a non-nullable argument exists, it stops
     * there (ignoring any further arguments' types) and exludes null from the final
     * union type.
     *
     * `(string | null, number | null)` is inferred as `string | number | null`.
     *
     * `(string | null, number, Date | null)` is inferred as `string | number`.
     *
     * `(number, string | null)` is inferred as `number`.
     *
     * ### Examples
     *
     * ```ts
     * const { coalesce } = db.fn
     *
     * db.selectFrom('participant')
     *   .select(coalesce('nickname', sql<string>`'<anonymous>'`).as('nickname'))
     *   .where('room_id', '=', roomId)
     *   .execute()
     * ```
     *
     * The generated SQL (PostgreSQL):
     *
     * ```sql
     * select coalesce("nickname", '<anonymous>') as "nickname"
     * from "participant" where "room_id" = $1
     * ```
     *
     * You can limit column range to only columns participating in current query:
     *
     * ```ts
     * db.selectFrom('participant')
     *   .select(qb =>
     *     qb.fn.coalesce('nickname', sql<string>`'<anonymous>'`).as('nickname')
     *   )
     *   .where('room_id', '=', roomId)
     *   .execute()
     * ```
     *
     * You can combine this function with other helpers in this module:
     *
     * ```ts
     * const { avg, coalesce } = db.fn
     *
     * db.selectFrom('person')
     *   .select(coalesce(avg<number | null>('age'), sql<number>`0`).as('avg_age'))
     *   .where('first_name', '=', 'Jennifer')
     *   .execute()
     * ```
     *
     * The generated SQL (PostgreSQL):
     *
     * ```sql
     * select coalesce(avg("age"), 0) as "avg_age" from "person" where "first_name" = $1
     * ```
     */
    coalesce(value, ...otherValues) {
        return new raw_builder_js_1.RawBuilder({
            queryId: (0, query_id_js_1.createQueryId)(),
            rawNode: (0, coalesce_parser_js_1.parseCoalesce)([value, ...otherValues]),
        });
    }
    /**
     * Calls the `count` function for the column given as the argument.
     *
     * When called with a column as argument, this sql function counts the number of rows where there
     * is a non-null value in that column.
     *
     * For counting all rows nulls included (`count(*)`), see {@link countAll}.
     *
     * For additional functionality such as distinct, filtering and window functions,
     * refer to {@link AggregateFunctionBuilder}. An instance of this builder is
     * returned when calling this function.
     *
     * ### Examples
     *
     * ```ts
     * const { count } = db.fn
     *
     * db.selectFrom('toy')
     *   .select(count('id').as('num_toys'))
     *   .execute()
     * ```
     *
     * The generated SQL (PostgreSQL):
     *
     * ```sql
     * select count("id") as "num_toys" from "toy"
     * ```
     *
     * If this function is used in a `select` statement, the type of the selected
     * expression will be `number | string | bigint` by default. This is because
     * Kysely can't know the type the db driver outputs. Sometimes the output can
     * be larger than the largest javascript number and a string is returned instead.
     * Most drivers allow you to configure the output type of large numbers and Kysely
     * can't know if you've done so.
     *
     * You can specify the output type of the expression by providing
     * the type as the first type argument:
     *
     * ```ts
     * const { count } = db.fn
     *
     * db.selectFrom('toy')
     *   .select(count<number>('id').as('num_toys'))
     *   .execute()
     * ```
     *
     * You can limit column range to only columns participating in current query:
     *
     * ```ts
     * db.selectFrom('toy')
     *   .select(qb => qb.fn.count('id').as('num_toys'))
     *   .execute()
     * ```
     */
    count(column) {
        return new aggregate_function_builder_js_1.AggregateFunctionBuilder({
            aggregateFunctionNode: aggregate_function_node_js_1.AggregateFunctionNode.create('count', (0, reference_parser_js_1.parseSimpleReferenceExpression)(column)),
        });
    }
    countAll(table) {
        return new aggregate_function_builder_js_1.AggregateFunctionBuilder({
            aggregateFunctionNode: aggregate_function_node_js_1.AggregateFunctionNode.create('count', (0, select_parser_js_1.parseSelectAll)(table)[0].selection),
        });
    }
    max(column) {
        return new aggregate_function_builder_js_1.AggregateFunctionBuilder({
            aggregateFunctionNode: aggregate_function_node_js_1.AggregateFunctionNode.create('max', (0, reference_parser_js_1.parseSimpleReferenceExpression)(column)),
        });
    }
    min(column) {
        return new aggregate_function_builder_js_1.AggregateFunctionBuilder({
            aggregateFunctionNode: aggregate_function_node_js_1.AggregateFunctionNode.create('min', (0, reference_parser_js_1.parseSimpleReferenceExpression)(column)),
        });
    }
    /**
     * Calls the `sum` function for the column given as the argument.
     *
     * This sql function sums the values of a given column.
     *
     * For additional functionality such as distinct, filtering and window functions,
     * refer to {@link AggregateFunctionBuilder}. An instance of this builder is
     * returned when calling this function.
     *
     * ### Examples
     *
     * ```ts
     * const { sum } = db.fn
     *
     * db.selectFrom('toy')
     *   .select(sum('price').as('total_price'))
     *   .execute()
     * ```
     *
     * The generated SQL (PostgreSQL):
     *
     * ```sql
     * select sum("price") as "total_price" from "toy"
     * ```
     *
     * You can limit column range to only columns participating in current query:
     *
     * ```ts
     * db.selectFrom('toy')
     *   .select(qb => qb.fn.sum('price').as('total_price'))
     *   .execute()
     * ```
     *
     * If this function is used in a `select` statement, the type of the selected
     * expression will be `number | string` by default. This is because Kysely can't know the
     * type the db driver outputs. Sometimes the output can be larger than the largest
     * javascript number and a string is returned instead. Most drivers allow you
     * to configure the output type of large numbers and Kysely can't know if you've
     * done so.
     *
     * You can specify the output type of the expression by providing the type as
     * the first type argument:
     *
     * ```ts
     * const { sum } = db.fn
     *
     * db.selectFrom('toy')
     *   .select(sum<number>('price').as('total_price'))
     *   .execute()
     * ```
     *
     * Sometimes a null is returned, e.g. when row count is 0, and no `group by`
     * was used. It is highly recommended to include null in the output type union
     * and handle null values in post-execute code, or wrap the function with a {@link coalesce}
     * function.
     *
     * ```ts
     * const { sum } = db.fn
     *
     * db.selectFrom('toy')
     *   .select(sum<number | null>('price').as('total_price'))
     *   .execute()
     * ```
     */
    sum(column) {
        return new aggregate_function_builder_js_1.AggregateFunctionBuilder({
            aggregateFunctionNode: aggregate_function_node_js_1.AggregateFunctionNode.create('sum', (0, reference_parser_js_1.parseSimpleReferenceExpression)(column)),
        });
    }
}
exports.FunctionModule = FunctionModule;
