"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseFilterExpression = exports.parseReferentialFilter = exports.parseOn = exports.parseHaving = exports.parseWhere = void 0;
const binary_operation_node_js_1 = require("../operation-node/binary-operation-node.js");
const object_utils_js_1 = require("../util/object-utils.js");
const operation_node_source_js_1 = require("../operation-node/operation-node-source.js");
const raw_node_js_1 = require("../operation-node/raw-node.js");
const operator_node_js_1 = require("../operation-node/operator-node.js");
const parens_node_js_1 = require("../operation-node/parens-node.js");
const reference_parser_js_1 = require("./reference-parser.js");
const value_parser_js_1 = require("./value-parser.js");
const value_node_js_1 = require("../operation-node/value-node.js");
const parse_utils_js_1 = require("./parse-utils.js");
function parseWhere(args) {
    return parseFilterExpression('where', args);
}
exports.parseWhere = parseWhere;
function parseHaving(args) {
    return parseFilterExpression('having', args);
}
exports.parseHaving = parseHaving;
function parseOn(args) {
    return parseFilterExpression('on', args);
}
exports.parseOn = parseOn;
function parseReferentialFilter(leftOperand, operator, rightOperand) {
    return binary_operation_node_js_1.BinaryOperationNode.create((0, reference_parser_js_1.parseReferenceExpression)(leftOperand), parseComparisonOperatorExpression(operator), (0, reference_parser_js_1.parseReferenceExpression)(rightOperand));
}
exports.parseReferentialFilter = parseReferentialFilter;
function parseFilterExpression(type, args) {
    if (args.length === 3) {
        return parseFilter(args[0], args[1], args[2]);
    }
    if (args.length === 1) {
        return parseOneArgFilterExpression(type, args[0]);
    }
    throw createFilterExpressionError(type, args);
}
exports.parseFilterExpression = parseFilterExpression;
function parseFilter(leftOperand, operator, rightOperand) {
    if ((operator === 'is' || operator === 'is not') &&
        ((0, object_utils_js_1.isNull)(rightOperand) || (0, object_utils_js_1.isBoolean)(rightOperand))) {
        return parseIs(leftOperand, operator, rightOperand);
    }
    return binary_operation_node_js_1.BinaryOperationNode.create((0, reference_parser_js_1.parseReferenceExpression)(leftOperand), parseComparisonOperatorExpression(operator), (0, value_parser_js_1.parseValueExpressionOrList)(rightOperand));
}
function parseIs(leftOperand, operator, rightOperand) {
    return binary_operation_node_js_1.BinaryOperationNode.create((0, reference_parser_js_1.parseReferenceExpression)(leftOperand), parseComparisonOperatorExpression(operator), value_node_js_1.ValueNode.createImmediate(rightOperand));
}
function parseComparisonOperatorExpression(operator) {
    if ((0, object_utils_js_1.isString)(operator) && operator_node_js_1.COMPARISON_OPERATORS.includes(operator)) {
        return operator_node_js_1.OperatorNode.create(operator);
    }
    else if ((0, operation_node_source_js_1.isOperationNodeSource)(operator)) {
        return operator.toOperationNode();
    }
    throw new Error(`invalid comparison operator ${JSON.stringify(operator)} passed to a filter method`);
}
function parseOneArgFilterExpression(type, arg) {
    if ((0, object_utils_js_1.isFunction)(arg)) {
        return GROUP_PARSERS[type](arg);
    }
    else if ((0, operation_node_source_js_1.isOperationNodeSource)(arg)) {
        const node = arg.toOperationNode();
        if (raw_node_js_1.RawNode.is(node)) {
            return node;
        }
    }
    throw createFilterExpressionError(type, arg);
}
function createFilterExpressionError(type, args) {
    return new Error(`invalid arguments passed to a '${type}' method: ${JSON.stringify(args)}`);
}
const GROUP_PARSERS = (0, object_utils_js_1.freeze)({
    where(callback) {
        const query = callback((0, parse_utils_js_1.createSelectQueryBuilder)());
        const queryNode = query.toOperationNode();
        if (!queryNode.where) {
            throw new Error('no `where` methods called inside a group callback');
        }
        return parens_node_js_1.ParensNode.create(queryNode.where.where);
    },
    having(callback) {
        const query = callback((0, parse_utils_js_1.createSelectQueryBuilder)());
        const queryNode = query.toOperationNode();
        if (!queryNode.having) {
            throw new Error('no `having` methods called inside a group callback');
        }
        return parens_node_js_1.ParensNode.create(queryNode.having.having);
    },
    on(callback) {
        const joinBuilder = callback((0, parse_utils_js_1.createJoinBuilder)('InnerJoin', 'table'));
        const joinNode = joinBuilder.toOperationNode();
        if (!joinNode.on) {
            throw new Error('no `on` methods called inside a group callback');
        }
        return parens_node_js_1.ParensNode.create(joinNode.on.on);
    },
});
