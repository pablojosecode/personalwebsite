/// <reference types="./function-module.d.ts" />
import { AggregateFunctionNode } from '../operation-node/aggregate-function-node.js';
import { parseCoalesce, } from '../parser/coalesce-parser.js';
import { parseSimpleReferenceExpression, } from '../parser/reference-parser.js';
import { RawBuilder } from '../raw-builder/raw-builder.js';
import { createQueryId } from '../util/query-id.js';
import { AggregateFunctionBuilder } from './aggregate-function-builder.js';
/**
 * Helpers for type safe SQL function calls.
 *
 * You can always use the {@link sql} tag to call functions and build arbitrary
 * expressions. This module simply has shortcuts for most common function calls.
 *
 * ### Examples
 *
 * ```ts
 * const { count } = db.fn
 *
 * await db.selectFrom('person')
 *   .innerJoin('pet', 'pet.owner_id', 'person.id')
 *   .select([
 *     'person.id',
 *     count('pet.id').as('pet_count')
 *   ])
 *   .groupBy('person.id')
 *   .having(count('pet.id'), '>', 10)
 *   .execute()
 * ```
 *
 * The generated SQL (PostgreSQL):
 *
 * ```sql
 * select "person"."id", count("pet"."id") as "pet_count"
 * from "person"
 * inner join "pet" on "pet"."owner_id" = "person"."id"
 * group by "person"."id"
 * having count("pet"."id") > $1
 * ```
 */
export class FunctionModule {
    constructor() {
        this.avg = this.avg.bind(this);
        this.coalesce = this.coalesce.bind(this);
        this.count = this.count.bind(this);
        this.max = this.max.bind(this);
        this.min = this.min.bind(this);
        this.sum = this.sum.bind(this);
    }
    /**
     * Calls the `avg` function for the column given as the argument.
     *
     * If this is used in a `select` statement the type of the selected expression
     * will be `number | string` by default. This is because Kysely can't know the
     * type the db driver outputs. Sometimes the output can be larger than the largest
     * javascript number and a string is returned instead. Most drivers allow you
     * to configure the output type of large numbers and Kysely can't know if you've
     * done so.
     *
     * You can specify the output type of the expression by providing the type as
     * the first type argument:
     *
     * ```ts
     * const { avg } = db.fn
     *
     * db.selectFrom('toy')
     *   .select(avg<number>('price').as('avg_price'))
     *   .execute()
     * ```
     *
     * Sometimes a null is returned, e.g. when row count is 0, and no `group by`
     * was used. It is highly recommended to include null in the output type union
     * and handle null values in post-execute code, or wrap the function with a `coalesce`
     * function.
     *
     * ```ts
     * const { avg } = db.fn
     *
     * db.selectFrom('toy')
     *   .select(avg<number | null>('price').as('avg_price'))
     *   .execute()
     * ```
     */
    avg(column) {
        return new AggregateFunctionBuilder({
            aggregateFunctionNode: AggregateFunctionNode.create('avg', parseSimpleReferenceExpression(column)),
        });
    }
    /**
     * Calls the `coalesce` function for given arguments.
     *
     * This function returns the first non-null value from left to right, commonly
     * used to provide a default scalar for nullable columns or functions.
     *
     * ```ts
     * const { coalesce, max } = db.fn
     *
     * db.selectFrom('person')
     *   .select(coalesce(max('age'), sql<number>`0`).as('max_age'))
     *   .where('first_name', '=', 'Jennifer')
     *   .execute()
     * ```
     *
     * The generated SQL (postgres):
     *
     * ```sql
     * select coalesce(max("age"), 0) as "max_age" from "person" where "first_name" = $1
     * ```
     *
     * If this is used in a `select` statement the type of the selected expression
     * is inferred in the same manner that the function computes. A union of arguments'
     * types - if a non-nullable argument exists, it stops there (ignoring any further
     * arguments' types) and exludes null from the final union type.
     *
     * Examples:
     *
     * `(string | null, number | null)` is inferred as `string | number | null`.
     *
     * `(string | null, number, Date | null)` is inferred as `string | number`.
     *
     * `(number, string | null)` is inferred as `number`.
     */
    coalesce(value, ...otherValues) {
        return new RawBuilder({
            queryId: createQueryId(),
            rawNode: parseCoalesce([value, ...otherValues]),
        });
    }
    /**
     * Calls the `count` function for the column given as the argument.
     *
     * If this is used in a `select` statement the type of the selected expression
     * will be `number | string | bigint` by default. This is because Kysely
     * can't know the type the db driver outputs. Sometimes the output can be larger
     * than the largest javascript number and a string is returned instead. Most
     * drivers allow you to configure the output type of large numbers and Kysely
     * can't know if you've done so.
     *
     * You can specify the output type of the expression by providing
     * the type as the first type argument:
     *
     * ```ts
     * const { count } = db.fn
     *
     * db.selectFrom('toy')
     *   .select(count<number>('id').as('num_toys'))
     *   .execute()
     * ```
     *
     * You can limit column range:
     *
     * ```ts
     * db.selectFrom('toy')
     *   .select(qb => qb.fn.count<number>('id').as('num_toys'))
     *   .execute()
     * ```
     */
    count(column) {
        return new AggregateFunctionBuilder({
            aggregateFunctionNode: AggregateFunctionNode.create('count', parseSimpleReferenceExpression(column)),
        });
    }
    max(column) {
        return new AggregateFunctionBuilder({
            aggregateFunctionNode: AggregateFunctionNode.create('max', parseSimpleReferenceExpression(column)),
        });
    }
    min(column) {
        return new AggregateFunctionBuilder({
            aggregateFunctionNode: AggregateFunctionNode.create('min', parseSimpleReferenceExpression(column)),
        });
    }
    /**
     * Calls the `sum` function for the column given as the argument.
     *
     * If this is used in a `select` statement the type of the selected expression
     * will be `number | string | bigint` by default. This is because Kysely
     * can't know the type the db driver outputs. Sometimes the output can be larger
     * than the largest javascript number and a string is returned instead. Most
     * drivers allow you to configure the output type of large numbers and Kysely
     * can't know if you've done so.
     *
     * You can specify the output type of the expression by providing
     * the type as the first type argument:
     *
     * ```ts
     * const { sum } = db.fn
     *
     * db.selectFrom('toy')
     *   .select(sum<number>('price').as('total_price'))
     *   .execute()
     * ```
     *
     * Sometimes a null is returned, e.g. when row count is 0, and no `group by`
     * was used. It is highly recommended to include null in the output type union
     * and handle null values in post-execute code, or wrap the function with a `coalesce`
     * function.
     *
     * ```ts
     * const { sum } = db.fn
     *
     * db.selectFrom('toy')
     *   .select(sum<number | null>('price').as('total_price'))
     *   .execute()
     * ```
     */
    sum(column) {
        return new AggregateFunctionBuilder({
            aggregateFunctionNode: AggregateFunctionNode.create('sum', parseSimpleReferenceExpression(column)),
        });
    }
}
