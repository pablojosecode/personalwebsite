var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};

// src/index.ts
import { cast, connect } from "@planetscale/database";
import { parseJSON } from "date-fns";
import {
  MysqlAdapter,
  MysqlIntrospector,
  MysqlQueryCompiler
} from "kysely";
var _config;
var PlanetScaleDialect = class {
  constructor(config) {
    __privateAdd(this, _config, void 0);
    __privateSet(this, _config, config);
  }
  createAdapter() {
    return new MysqlAdapter();
  }
  createDriver() {
    return new PlanetScaleDriver(__privateGet(this, _config));
  }
  createQueryCompiler() {
    return new MysqlQueryCompiler();
  }
  createIntrospector(db) {
    return new MysqlIntrospector(db);
  }
};
_config = new WeakMap();
var _config2;
var PlanetScaleDriver = class {
  constructor(config) {
    __privateAdd(this, _config2, void 0);
    __privateSet(this, _config2, config);
  }
  async init() {
  }
  async acquireConnection() {
    return new PlanetScaleConnection(__privateGet(this, _config2));
  }
  async beginTransaction(conn) {
    return await conn.beginTransaction();
  }
  async commitTransaction(conn) {
    return await conn.commitTransaction();
  }
  async rollbackTransaction(conn) {
    return await conn.rollbackTransaction();
  }
  async releaseConnection(_conn2) {
  }
  async destroy() {
  }
};
_config2 = new WeakMap();
var _config3, _conn, _transactionClient;
var _PlanetScaleConnection = class {
  constructor(config) {
    __privateAdd(this, _config3, void 0);
    __privateAdd(this, _conn, void 0);
    __privateAdd(this, _transactionClient, void 0);
    __privateSet(this, _config3, config);
    __privateSet(this, _conn, connect({ cast: inflateDates, ...config }));
  }
  async executeQuery(compiledQuery) {
    if (__privateGet(this, _transactionClient))
      return __privateGet(this, _transactionClient).executeQuery(compiledQuery);
    const parameters = __privateGet(this, _config3).format ? compiledQuery.parameters : compiledQuery.parameters.map((param) => param instanceof Date ? formatDate(param) : param);
    const results = await __privateGet(this, _conn).execute(compiledQuery.sql, parameters);
    if (results.error) {
      throw results.error;
    }
    const numAffectedRows = results.rowsAffected == null ? void 0 : BigInt(results.rowsAffected);
    return {
      insertId: results.insertId !== null && results.insertId.toString() !== "0" ? BigInt(results.insertId) : void 0,
      rows: results.rows,
      numAffectedRows,
      numUpdatedOrDeletedRows: numAffectedRows
    };
  }
  async beginTransaction() {
    __privateSet(this, _transactionClient, __privateGet(this, _transactionClient) ?? new _PlanetScaleConnection(__privateGet(this, _config3)));
    await __privateGet(__privateGet(this, _transactionClient), _conn).execute("BEGIN");
  }
  async commitTransaction() {
    if (!__privateGet(this, _transactionClient))
      throw new Error("No transaction to commit");
    try {
      await __privateGet(__privateGet(this, _transactionClient), _conn).execute("COMMIT");
    } finally {
      __privateSet(this, _transactionClient, void 0);
    }
  }
  async rollbackTransaction() {
    if (!__privateGet(this, _transactionClient))
      throw new Error("No transaction to rollback");
    try {
      await __privateGet(__privateGet(this, _transactionClient), _conn).execute("ROLLBACK");
    } finally {
      __privateSet(this, _transactionClient, void 0);
    }
  }
  async *streamQuery(_compiledQuery, _chunkSize) {
    throw new Error("PlanetScale Serverless Driver does not support streaming");
  }
};
var PlanetScaleConnection = _PlanetScaleConnection;
_config3 = new WeakMap();
_conn = new WeakMap();
_transactionClient = new WeakMap();
function inflateDates(field, value) {
  if (field.type === "DATETIME" && value)
    return parseJSON(value);
  if (field.type === "TIMESTAMP" && value)
    return parseJSON(value);
  return cast(field, value);
}
function formatDate(date) {
  return date.toISOString().replace(/[TZ]/g, " ").trim();
}
export {
  PlanetScaleDialect,
  inflateDates
};
