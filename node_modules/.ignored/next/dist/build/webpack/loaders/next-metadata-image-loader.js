"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = exports.raw = void 0;
var _path = _interopRequireDefault(require("path"));
var _loaderUtils3 = _interopRequireDefault(require("next/dist/compiled/loader-utils3"));
var _imageOptimizer = require("../../../server/image-optimizer");
var _mimeType = require("../../../lib/mime-type");
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
async function nextMetadataImageLoader(content) {
    const options = this.getOptions();
    const { type , route , pageExtensions  } = options;
    const numericSizes = type === "twitter" || type === "openGraph";
    const { resourcePath , rootContext: context  } = this;
    const { name: filename , ext  } = _path.default.parse(resourcePath);
    let extension = ext.slice(1);
    if (extension === "jpg") {
        extension = "jpeg";
    }
    const opts = {
        context,
        content
    };
    const interpolatedName = _loaderUtils3.default.interpolateName(this, "[name].[ext]", opts);
    // No hash query for favicon.ico
    const contentHash = type === "favicon" ? "" : _loaderUtils3.default.interpolateName(this, "[contenthash]", opts);
    const outputPath = route + "/" + interpolatedName + (contentHash ? `?${contentHash}` : "");
    const isDynamicResource = pageExtensions.includes(extension);
    if (isDynamicResource) {
        // re-export and spread as `exportedImageData` to avoid non-exported error
        return `\
    import * as exported from ${JSON.stringify(resourcePath)}

    const exportedImageData = { ...exported }
    const imageData = {
      alt: exportedImageData.alt,
      type: exportedImageData.contentType,
      url: ${JSON.stringify(route + "/" + filename + "?" + contentHash)},
    }
    const { size } = exportedImageData
    if (size) {
      ${type === "twitter" || type === "openGraph" ? "imageData.width = size.width; imageData.height = size.height;" : 'imageData.sizes = size.width + "x" + size.height;'}
    }
    export default imageData`;
    }
    const imageSize = await (0, _imageOptimizer).getImageSize(content, extension).catch((err)=>err);
    if (imageSize instanceof Error) {
        const err = imageSize;
        err.name = "InvalidImageFormatError";
        throw err;
    }
    const imageData = {
        url: outputPath,
        ...extension in _mimeType.imageExtMimeTypeMap && {
            type: _mimeType.imageExtMimeTypeMap[extension]
        },
        ...numericSizes ? {
            width: imageSize.width,
            height: imageSize.height
        } : {
            sizes: extension === "ico" ? "any" : `${imageSize.width}x${imageSize.height}`
        }
    };
    const stringifiedData = JSON.stringify(imageData);
    return `export default ${stringifiedData};`;
}
const raw = true;
exports.raw = raw;
var _default = nextMetadataImageLoader;
exports.default = _default;

//# sourceMappingURL=next-metadata-image-loader.js.map