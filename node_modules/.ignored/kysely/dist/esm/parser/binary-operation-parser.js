/// <reference types="./binary-operation-parser.d.ts" />
import { BinaryOperationNode } from '../operation-node/binary-operation-node.js';
import { freeze, isBoolean, isFunction, isNull, isString, } from '../util/object-utils.js';
import { isOperationNodeSource } from '../operation-node/operation-node-source.js';
import { RawNode } from '../operation-node/raw-node.js';
import { OperatorNode, COMPARISON_OPERATORS, } from '../operation-node/operator-node.js';
import { ParensNode } from '../operation-node/parens-node.js';
import { parseReferenceExpression, } from './reference-parser.js';
import { parseValueExpressionOrList, } from './value-parser.js';
import { ValueNode } from '../operation-node/value-node.js';
import { createJoinBuilder, createSelectQueryBuilder } from './parse-utils.js';
export function parseWhere(args) {
    return parseFilterExpression('where', args);
}
export function parseHaving(args) {
    return parseFilterExpression('having', args);
}
export function parseOn(args) {
    return parseFilterExpression('on', args);
}
export function parseReferentialFilter(leftOperand, operator, rightOperand) {
    return BinaryOperationNode.create(parseReferenceExpression(leftOperand), parseComparisonOperatorExpression(operator), parseReferenceExpression(rightOperand));
}
export function parseFilterExpression(type, args) {
    if (args.length === 3) {
        return parseFilter(args[0], args[1], args[2]);
    }
    if (args.length === 1) {
        return parseOneArgFilterExpression(type, args[0]);
    }
    throw createFilterExpressionError(type, args);
}
function parseFilter(leftOperand, operator, rightOperand) {
    if ((operator === 'is' || operator === 'is not') &&
        (isNull(rightOperand) || isBoolean(rightOperand))) {
        return parseIs(leftOperand, operator, rightOperand);
    }
    return BinaryOperationNode.create(parseReferenceExpression(leftOperand), parseComparisonOperatorExpression(operator), parseValueExpressionOrList(rightOperand));
}
function parseIs(leftOperand, operator, rightOperand) {
    return BinaryOperationNode.create(parseReferenceExpression(leftOperand), parseComparisonOperatorExpression(operator), ValueNode.createImmediate(rightOperand));
}
function parseComparisonOperatorExpression(operator) {
    if (isString(operator) && COMPARISON_OPERATORS.includes(operator)) {
        return OperatorNode.create(operator);
    }
    else if (isOperationNodeSource(operator)) {
        return operator.toOperationNode();
    }
    throw new Error(`invalid comparison operator ${JSON.stringify(operator)} passed to a filter method`);
}
function parseOneArgFilterExpression(type, arg) {
    if (isFunction(arg)) {
        return GROUP_PARSERS[type](arg);
    }
    else if (isOperationNodeSource(arg)) {
        const node = arg.toOperationNode();
        if (RawNode.is(node)) {
            return node;
        }
    }
    throw createFilterExpressionError(type, arg);
}
function createFilterExpressionError(type, args) {
    return new Error(`invalid arguments passed to a '${type}' method: ${JSON.stringify(args)}`);
}
const GROUP_PARSERS = freeze({
    where(callback) {
        const query = callback(createSelectQueryBuilder());
        const queryNode = query.toOperationNode();
        if (!queryNode.where) {
            throw new Error('no `where` methods called inside a group callback');
        }
        return ParensNode.create(queryNode.where.where);
    },
    having(callback) {
        const query = callback(createSelectQueryBuilder());
        const queryNode = query.toOperationNode();
        if (!queryNode.having) {
            throw new Error('no `having` methods called inside a group callback');
        }
        return ParensNode.create(queryNode.having.having);
    },
    on(callback) {
        const joinBuilder = callback(createJoinBuilder('InnerJoin', 'table'));
        const joinNode = joinBuilder.toOperationNode();
        if (!joinNode.on) {
            throw new Error('no `on` methods called inside a group callback');
        }
        return ParensNode.create(joinNode.on.on);
    },
});
