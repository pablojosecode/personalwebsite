import type { RequestAsyncStorage, RequestStore } from '../../../client/components/request-async-storage';
import type { Params } from '../../../shared/lib/router/utils/route-matcher';
import type { AsyncStorageWrapper } from '../../async-storage/async-storage-wrapper';
import { type RequestContext } from '../../async-storage/request-async-storage-wrapper';
import { BaseNextRequest, BaseNextResponse } from '../../base-http';
import { AppRouteRouteMatch } from '../route-matches/app-route-route-match';
import { HTTP_METHOD } from '../../web/http';
import type { ModuleLoader } from '../helpers/module-loader/module-loader';
import { RouteHandler } from './route-handler';
import { StaticGenerationAsyncStorage, StaticGenerationStore } from '../../../client/components/static-generation-async-storage';
import { StaticGenerationAsyncStorageWrapper } from '../../async-storage/static-generation-async-storage-wrapper';
import { IncrementalCache } from '../../lib/incremental-cache';
import { AppConfig } from '../../../build/utils';
import { NextConfig } from '../../config-shared';
/**
 * Handler function for app routes.
 */
export declare type AppRouteHandlerFn = (
/**
 * Incoming request object.
 */
req: Request, 
/**
 * Context properties on the request (including the parameters if this was a
 * dynamic route).
 */
ctx: {
    params?: Params;
}) => Response;
/**
 * AppRouteModule is the specific userland module that is exported. This will
 * contain the HTTP methods that this route can respond to.
 */
export declare type AppRouteModule = {
    /**
     * Contains all the exported userland code.
     */
    handlers: Record<HTTP_METHOD, AppRouteHandlerFn> & Record<'dynamic', AppConfig['dynamic']> & Record<'revalidate', AppConfig['revalidate']> & Record<'fetchCache', AppConfig['fetchCache']>;
    /**
     * The exported async storage object for this worker/module.
     */
    requestAsyncStorage: RequestAsyncStorage;
    /**
     * The absolute path to the module file
     */
    resolvedPagePath: string;
    staticGenerationAsyncStorage: StaticGenerationAsyncStorage;
    serverHooks: typeof import('../../../client/components/hooks-server-context');
    headerHooks: typeof import('../../../client/components/headers');
    staticGenerationBailout: typeof import('../../../client/components/static-generation-bailout').staticGenerationBailout;
};
export declare type StaticGenerationContext = {
    incrementalCache?: IncrementalCache;
    supportsDynamicHTML: boolean;
    nextExport?: boolean;
    fetchCache?: StaticGenerationStore['fetchCache'];
};
export declare class AppRouteRouteHandler implements RouteHandler<AppRouteRouteMatch> {
    private readonly nextConfigOutput;
    private readonly requestAsyncLocalStorageWrapper;
    protected readonly staticAsyncLocalStorageWrapper: StaticGenerationAsyncStorageWrapper;
    protected readonly moduleLoader: ModuleLoader;
    /**
     * The module for this handler. When set, this will be used instead of loading
     * the module from the loader.
     */
    module: AppRouteModule | undefined;
    constructor(nextConfigOutput?: NextConfig['output'], requestAsyncLocalStorageWrapper?: AsyncStorageWrapper<RequestStore, RequestContext>, staticAsyncLocalStorageWrapper?: StaticGenerationAsyncStorageWrapper, moduleLoader?: ModuleLoader);
    private resolve;
    /**
     * Loads and patches the module for the given route definition unless it's
     * already been loaded.
     *
     * @param definition the route definition to load the module for
     * @returns the loaded and patched module
     */
    private load;
    execute({ params, definition }: AppRouteRouteMatch, req: BaseNextRequest, res: BaseNextResponse, context?: StaticGenerationContext): Promise<Response>;
    handle(match: AppRouteRouteMatch, req: BaseNextRequest, res: BaseNextResponse, context?: StaticGenerationContext): Promise<Response>;
}
